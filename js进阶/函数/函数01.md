# JS 中的内存管理

## 前端为什么要去关注内存

栈溢出: 可用内存小于程序运行的内存
防止页面占用内存过大, 引起客户端卡顿, 甚至无响应
Node 使用 V8, 内存对于后端服务的性能至关重要, 因为后端服务的持久性, 后端更容易造成内存溢出

## JS 数据类型和 JS 的内存机制

1. 数据类型

- 原始数据类型: Sring, Number, Boolean, Null, Undefined, Symbol

- 应用数据类型: Object

- 内存空间: 栈内存(stack), 堆内存(heap)
  JS 中原市数据类型是有固定大小, 保存在栈中, 由系统分配存储空间, 我们可以直接进行操作, 因此原始数据类型可以按值访问. 栈是一种运算受限的线性表, 其限制仅允许在表的一端插入或删除运算

栈的顶端 -- 栈顶, 栈的底端 -- 栈底

- 定义变量的过程

```js
var a = 10;
//  1. 在栈中申明了 变量a, 此时a的值为undefined
//  2. 赋值a一个值10, 使a的值与10关联起来
//  3. 栈内存变量删除原则是先进后出原则, 先入栈的变量最后弹栈
```

```js
// 引用类型是在堆内存中存储, 栈内存中存储的是引用的地址
// 我们操作堆类型的数据, 都是操作堆内存的引用
var obj = { a: 1 };
// 1. 现在堆内存中开辟一个空间, 存储引用类型的值
// 2. 堆内存会有一个16进制的内存地址, 此时在栈内存中 变量obj的值就是这个内存地址
```

```js
// 函数类型也是引用类型
// 1. 函数首先会在堆内存中开辟一个空间, 将函数代码以代码字符串的形式存储到堆中, 同时给到一个16进制的内存地址
// 2. 然后将该内存地址赋值给到栈内存中变量
```

## 垃圾回收机制

### 垃圾回收

找出哪些不再继续使用的变量, 然后释放其所占用的内存, 垃圾回收器会按照固定的时间间隔周期性的执行这一操作

### 垃圾回收机制是一把双刃剑

优势: 可以大幅优化程序的内存管理代码, 降低程序员的负担, 减少因长时间运转而打来的内存泄露问题
缺点: 意味着程序员将无法掌控内存. JS 内有暴露任何关于内存的 API, 我们无法强迫其进行垃圾回收, 更无法干预内存管理

### 引用计数(reference counting)

跟踪记录每个值被引用的次数, 如果一个值的引用次数是 0, 表示这个值不再被使用, 因此可以将这块内存释放
原理: 每次引用加一, 被释放时减一, 当这个值的引用次数变成 0, 就可以将其内存空间回收

引用类型有个严重 bug: 循环引用, 即相互引用

```js
function fn() {
  var objA = { a: 10 };
  var objB = { b: 10 };
  objA.c = objA;
  objB.d = objB;
}

// objA和objB被各自的属性相互引用, 当函数执行完毕后, objA和objB并没有被销毁,
// 如果这个函数被大量调用, 会造成严重的性能问题
// 这个问题仅存在于ie8之前的浏览器, 现代浏览器没有这个问题了
```

### 标记清除

标记清除指的是当变量进入环境时, 这个变量标记为进入环境, 而当变量离开环境时, 而将其标记为离开环境, 最后, 垃圾收集器完成内存清楚工作, 销毁那些带标记的值并回收他们所占用的内存空间

### 执行环境

执行环境定义了变量或函数有权访问的其他数据, 决定了它们的各自的行为. 每个执行环境都有一个与之关联的变量对象(varibale object), 环境中定义的所有变量和函数都保存在这个对象中

1. 全局执行环境

- 最外围的一个执行环境
- 根据宿主环境不同表示执行环境的对象也不一样. 在浏览器中, 全局执行环境被认为是 window 对象
- 全局变量和函数都是作为 window 对象的属性和方法被创建的
- 某个执行环境中的所有代码执行完毕后, 该环境被销毁, 保存在其中的所有变量和函数定义也随之销毁

2. 环境栈(局部)
   每个函数都有自己的执行环境. 当执行流进入一个函数时, 函数的环境就会被推入一个环境栈中. 而在函数执行之后, 栈将其环境弹出, 把控制权返回给之前的执行环境. ECMA 程序中的执行流正是由这个方便的机制控制着

## V8 内存管理机制

- V8 最初为浏览器设计, 不太可能遇到大量内存的使用场景
  防止因为垃圾回收所导致的线程暂停执行时间过长

- V8 采用了一种分代回收的策略, 将内存分为两个生代: 新生代和老生代
  V8 分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率

### 新生代垃圾回收

- 将栈分为 2 个空间: Form 空间和 To 空间, 组成一个 Semispace
- 声明变量时会现在 Form 空间内分配, 在垃圾回收运行时, 会检查 Form 空间中的变量, 当变量需要被回收时会被留来 Form 空间, 不需要回收的变量会转移到 To 空间, 然后进行反转, 将 Form 和 To 空间转换, 垃圾回收时将 To 空间的变量全部销毁

### 新生代对象的晋升

1. 新生代垃圾回收过程中, 当一个对象经过多次复制后依然存活, 他将被认为是生命周期较长的对象, 随后会被移动到老生代中, 采用新的算法进行管理
2. 在 From 空间和 To 空间进行反转的过程中, 如果 To 空间中的使用量已经超过了 25%, 那么就将 From 中的对象直接晋升到老生代内存空间中

### 老生代垃圾回收

老生代内存空间是一个连续的结构

1. 标记清除(Mark Sweep)
   Mark Sweep 是将需要被回收的对象进行标记, 在垃圾回收运行时直接释放响应的地址空间
2. 标记合并(Mark Compact)
   由于标记清除会造成内存不连续的现象, 所以需要标记合并, Mark Compact 将存活的对象移动到一边, 将需要被回收的对象移动到另一边, 然后对需要被回收的对象区域进行整体的垃圾回收
