# 设计模式

## 设计原则

1. 开闭原则
   程序对扩展开放, 对修改关闭

2. 单一职责
   一个模块只做一件事情

3. 依赖倒置原则
   上层模块不应该依赖下层模块, 依赖应该抽象化

4. 接口隔离原则
   细化接口, 是其能力单一

5. 迪米特法则
   最少知识原则

6. 里氏替换原则
   关注于继承, 父类使用的地方, 都可以使用子类替换, 子类必须完全继承父类的属性和方法

## 设计模式的分类

### 创建型

可以帮助我们优雅的创建对象

- 工厂模式
- 单例模式
- 建造者模式
- 原型模式


    #### 封装目的
    1.  定义变量不会污染外部
    2. 能够作为一个模块调用
    3. 遵循开闭原则

    #### 什么是好的封装
    1. 变量外部不可见
    2. 调用接口使用
    3. 留出扩展接口

    #### 创建一个对象的模式
    1. 工厂模式
    方便我们大量创建对象, 当某一个对象经常创建的时候
    ```js
    工厂模式就是写一个方法, 只需要调用这个方法, 就能拿到你要的对象

    function Factory(type){
      switch(type){
        case 'type1':
        return new Type1();
        case 'type2'"
        return new Type2();
        ...
      }
    }

    ```

    2. 建造者模式
    需要组合出一个全局对象, 当要创建单个, 庞大的组合对象
    ```js
    把一个复杂的类各个部分, 拆分成独立的类, 然后再最终的类里组合到一块, final为最终给出去的类

    //模块1
    function Model1(){
    }
    // 模块2
    function Model2(){
    }
    // 最终使用的类
    function Final(){
      this.mode1 = new Model1();
      this.mode2 = new Model2()
    }

    ```

    3. 单例模式
    需要确保全局只有一个对象, 为了避免重复新建, 避免多个对象存在互相干扰
    ```js
    通过定义一个方法, 使用时只允许通过此方法拿到存在内部的同一实例化对象
    let Singleton = function(name){
      this.name = name
    }
    Singleton.getInstance = function(name){
      if(this.instance){
        return this.instance
      }
      return this.instance = new Singleton(name)
    }

    ```

### 结构型

帮助我们优雅的设计代码结构

- 外观模式
- 享元模式
- 适配器模式
- 桥接模式
- 装饰着模式

### 行为型

模块之间的模式总结, 帮助我们组织模块的行为

- 观察者模式
- 职责链模式
- 状态模式
- 命令模式
- 策略模式
- 迭代器模式

### 技巧型

帮助我们优化代码的技巧

- 链模式
- 惰性模式
- 委托模式
- 等待者模式
- 数据访问模式
